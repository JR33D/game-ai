{"version":3,"sources":["index.js"],"names":["Square","props","className","onClick","value","Board","i","this","squares","renderSquare","React","Component","Game","state","Array","fill","xIsNext","slice","calculateWinner","Promise","resolve","nextState","reject","setState","a","makeMove","ran","Math","floor","random","console","log","bestSquare","findRandomSquare","findBestSquare","status","winner","isBoardFilled","handleClick","reset","lines","length","b","c","player","availableSpots","push","opponent","minimax","isMax","square","score","best","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a0345a09.chunk.js","sourcesContent":["import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\nfunction Square(props) {\r\n  return (\r\n    <button className=\"square\" onClick={props.onClick}>\r\n      {props.value}\r\n    </button>\r\n  );\r\n}\r\n\r\nclass Board extends React.Component {\r\n  renderSquare(i) {\r\n    return (\r\n      <Square\r\n        value={this.props.squares[i]}\r\n        onClick={() => this.props.onClick(i)}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"board-row\">\r\n          {this.renderSquare(0)}\r\n          {this.renderSquare(1)}\r\n          {this.renderSquare(2)}\r\n        </div>\r\n        <div className=\"board-row\">\r\n          {this.renderSquare(3)}\r\n          {this.renderSquare(4)}\r\n          {this.renderSquare(5)}\r\n        </div>\r\n        <div className=\"board-row\">\r\n          {this.renderSquare(6)}\r\n          {this.renderSquare(7)}\r\n          {this.renderSquare(8)}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Game extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      squares: Array(9).fill(null),\r\n      xIsNext: true\r\n    };\r\n  }\r\n  \r\n  makeMove(i) {\r\n    const squares = this.state.squares.slice();\r\n    if (calculateWinner(squares) || squares[i]) {\r\n      return Promise.resolve();\r\n    }\r\n    squares[i] = this.state.xIsNext ? \"X\" : \"O\";\r\n    const nextState = {\r\n      squares: squares,\r\n      xIsNext: !this.state.xIsNext\r\n    };\r\n    \r\n    // Return a Promise that resolves when setState completes.\r\n    return new Promise((resolve, reject) => {\r\n      this.setState(nextState, resolve);\r\n    });\r\n  }\r\n\r\n  async handleClick(i) {\r\n    // Apply player move to square i\r\n    await this.makeMove(i);\r\n    \r\n    // Apply AI move\r\n    const squares = this.state.squares.slice();\r\n    let ran = Math.floor(Math.random() * 10);\r\n    console.log(\"Rand: \" + ran);\r\n    const bestSquare = (ran >= 9) ? findRandomSquare(squares, this.state.xIsNext ? \"X\" : \"O\") : findBestSquare(squares, this.state.xIsNext ? \"X\" : \"O\");\r\n    if (bestSquare !== -1) {\r\n      await this.makeMove(bestSquare); \r\n    }\r\n  }\r\n\r\n  reset() {\r\n    this.setState({\r\n      squares: Array(9).fill(null),\r\n      xIsNext: true\r\n    })\r\n  }\r\n\r\n  render() {\r\n    const winner = calculateWinner(this.state.squares);\r\n\r\n    let status;\r\n    if (winner) {\r\n      status = \"Winner: \" + winner;\r\n    }\r\n    else if (isBoardFilled(this.state.squares)) {\r\n      status = \"It's a Tie!\";\r\n    } else {\r\n      status = \"Next player: \" + (this.state.xIsNext ? \"X\" : \"O\");\r\n    }\r\n\r\n    return (\r\n      <div className=\"game\">\r\n        <div className=\"game-board\">\r\n          <Board\r\n            squares={this.state.squares}\r\n            onClick={i => this.handleClick(i)}\r\n          />\r\n        </div>\r\n        <div className=\"game-info\">\r\n          <div>{status}</div>\r\n          <div><button onClick={() => this.reset()}>Reset</button></div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(<Game />, document.getElementById(\"root\"));\r\n\r\nfunction calculateWinner(squares) {\r\n  const lines = [\r\n    [0, 1, 2],\r\n    [3, 4, 5],\r\n    [6, 7, 8],\r\n    [0, 3, 6],\r\n    [1, 4, 7],\r\n    [2, 5, 8],\r\n    [0, 4, 8],\r\n    [2, 4, 6]\r\n  ];\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const [a, b, c] = lines[i];\r\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n      return squares[a];\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction isBoardFilled(squares) {\r\n  for (let i = 0; i < squares.length; i++) {\r\n    if (squares[i] === null) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction findRandomSquare(squares, player) {\r\n  let availableSpots = [];\r\n  for (let i = 0; i < squares.length; i++) {\r\n    if(!squares[i]) {\r\n      availableSpots.push(i);\r\n    }\r\n  }\r\n  let move = Math.floor(Math.random() * availableSpots.length);\r\n  return availableSpots[move];\r\n}\r\n\r\nfunction findBestSquare(squares, player) {\r\n  // 'player' is the maximizing player\r\n  // 'opponent' is the minimizing player\r\n  const opponent = player === 'X' ? 'O' : 'X';\r\n  \r\n  const minimax = (squares, isMax) => {\r\n    const winner = calculateWinner(squares);\r\n    \r\n    // If player wins, score is +1\r\n    if (winner === player) return { square: -1, score: 1 };\r\n    \r\n    // If opponent wins, score is -1\r\n    if (winner === opponent) return { square: -1, score: -1 };\r\n    \r\n    // If Tie, score is 0\r\n    if (isBoardFilled(squares)) return { square: -1, score: 0 };\r\n    \r\n    // Initialize 'best'. If isMax, we want to maximize score, and minimize otherwise.\r\n    const best = { square: -1, score: isMax ? -1000 : 1000 };\r\n    \r\n    // Loop through every square on the board\r\n    for (let i = 0; i < squares.length; i++) {\r\n      // If square is already filled, it's not a valid move so skip it\r\n      if (squares[i]) {\r\n        continue;\r\n      }\r\n      \r\n      // If square is unfilled, then it's a valid move. Play the square.\r\n      squares[i] = isMax ? player : opponent;\r\n      // Simulate the game until the end game and get the score,\r\n      // by recursively calling minimax.\r\n      const score = minimax(squares, !isMax).score;\r\n      // Undo the move\r\n      squares[i] = null;\r\n\r\n      if (isMax) {\r\n        // Maximizing player; track the largest score and move.\r\n        if (score > best.score) {\r\n          best.score = score;\r\n          best.square = i;\r\n        }\r\n      } else {\r\n        // Minimizing opponent; track the smallest score and move.\r\n        if (score < best.score) {\r\n          best.score = score;\r\n          best.square = i;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // The move that leads to the best score at end game.\r\n    return best;\r\n  };\r\n  \r\n  // The best move for the 'player' given current board\r\n  return minimax(squares, true).square;\r\n}"],"sourceRoot":""}